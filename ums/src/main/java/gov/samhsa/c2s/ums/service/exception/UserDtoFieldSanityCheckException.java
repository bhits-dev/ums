package gov.samhsa.c2s.ums.service.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.Instant;
import java.util.Arrays;
import java.util.Random;

@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
public class UserDtoFieldSanityCheckException extends RuntimeException {
    /**
     * The hash algorithm to use when generating the unique event ID
     * <p>
     *     The following hash algorithms are recognized by all
     *     Java platform implementations:
     *     <ul>
     *         <li>SHA-256</li>
     *         <li>SHA-1</li>
     *         <li>MD5</li>
     *     </ul>
     * </p>
     */
    private static final String hashAlgorithm = "SHA-256";

    private String eventId;

    public UserDtoFieldSanityCheckException() {
        super();
        generateUniqueEventId();
    }

    public UserDtoFieldSanityCheckException(String message) {
        super(message);
        generateUniqueEventId();
    }

    public UserDtoFieldSanityCheckException(String message, Throwable cause) {
        super(message, cause);
        generateUniqueEventId();
    }

    public UserDtoFieldSanityCheckException(Throwable cause) {
        super(cause);
        generateUniqueEventId();
    }

    public UserDtoFieldSanityCheckException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) {
        super(message, cause, enableSuppression, writableStackTrace);
        generateUniqueEventId();
    }

    /**
     * Get the unique event ID for this instance of UserDtoFieldSanityCheckException
     *
     * @return The unique event ID
     */
    public String getEventId() {
        return this.eventId;
    }

    /**
     * Set the unique event ID for this instance of UserDtoFieldSanityCheckException
     * <p>
     *     NOTE: Calling this method will overwrite the value for event ID
     *     which was generated during instantiation from the constructor.
     * </p>
     *
     * @param eventId - The value to set for eventId
     */
    public void setEventId(String eventId) {
        this.eventId = eventId;
    }

    @Override
    public String toString() {
        String stringFromThrowable = super.toString();
        return stringFromThrowable.concat(" --- Unique Event ID: ").concat(getEventId());
    }

    @Override
    public String getMessage() {
        String msgFromThrowable = super.getMessage();
        return msgFromThrowable.concat(" --- Unique Event ID: ").concat(getEventId());
    }

    /**
     * Generates a unique event ID for each exception instance
     * <p>
     *     The unique ID is generated by concatenating the current
     *     time in milliseconds since Epoch and a randomly generated
     *     number, then calculating the hash of it.
     * </p>
     */
    private void generateUniqueEventId()  {
        String generatedEventId;

        // generate random number and store it as binary string representation
        Random r = new Random();
        String rndNumStr = Long.toBinaryString(r.longs(1).findFirst().getAsLong());

        // get current time as binary string representation of milliseconds since Epoch
        String currentTime = Long.toBinaryString(Instant.now().toEpochMilli());

        // Concatenate binary string representations of currentTime and rndNumStr and store result as byte array
        byte[] valueToHash = currentTime.concat(rndNumStr).getBytes();

        try {
            MessageDigest messageDigest = MessageDigest.getInstance(hashAlgorithm);

            // Update messageDigest with valueToHash
            messageDigest.update(valueToHash);

            // Calculate SHA-256 hash of valueToHash and store result as string
            generatedEventId = Arrays.toString(messageDigest.digest());
        } catch (NoSuchAlgorithmException e) {
            generatedEventId = Arrays.toString(valueToHash);
        }

        this.eventId = generatedEventId;
    }
}
